---
title: "Introduction to jdx: Extended Java Data Exchange for R and rJava"
output:
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Introduction to R6 classes}
  %\usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# The conversion tables have been copied from mapping.xlsx and converted to R character matrices.
rdata.tables <- "introduction-tables.RData"
load(rdata.tables)
```

## Java Data Exchange for R

The [jdx](https://cran.r-project.org/package=jdx) package builds on Simon Urbanek's excellent [rJava](https://cran.r-project.org/package=rJava) to simplify and extend data exchange between R and Java. Together, jdx and rJava provide a potent low-level interface for the Java platform. 
The jdx package was primarily developed to provide data exchange functionality for [jsr223](https://cran.r-project.org/package=jsr223), the high-level scripting interface for the Java platform. We provide jdx to developers who may want to extend existing rJava solutions. Developers of new applications are encouraged to use jsr223 for rapid application development with a relatively low learning curve.

The jdx package converts R data structures to generic Java objects and vice versa. In particular, R vectors, matrices, n-dimensional arrays, factors, data frames, tables, environments, and lists are converted to Java objects. Java objects implementing common Java classes are converted to R vectors, matrices, n-dimensional arrays, data frames, and lists. Several options are available for data conversion including row-major vs. column-major ordering for arrays and data frames.

For sites that plan on designing and distributing packages that depend on jdx, it may be helpful to know that the jdx package does not use or load rJava's companion package JRI (the Java/R Interface).

**Note**: The jdx package behavior diverges from rJava somewhat for `raw` values and Java values of type `byte` and `java.lang.Byte`. Please see [R raw Values and Java byte Values](#R_raw_Java_byte) for more information.

## Primary Functions

This example demonstrates the primary functions in jdx: `convertToJava()`, `convertToR()`, and `getJavaClassName()`. Notice that the call to `Arrays.deepToString()` reveals that `convertToJava()` uses row-major ordering for arrays by default.

```{r}
library("jdx")
m1 <- matrix(1:4, 2, 2)
m1
# Convert the matrix to a Java two-dimensional array (int[][]).
o <- convertToJava(m1)

# Display the class name.
getJavaClassName(o)

# Use rJava::.jcall to invoke the java.util.Arrays.deepToString
# method. deepToString requires a parameter of Object[]. Cast
# our int[][] array to Object[] before calling the method.
o <- rJava::.jcast(o, "[Ljava/lang/Object;")
rJava::.jcall("java/util/Arrays", "S", "deepToString", o)

# Convert the Java array back to an R matrix and show that
# it is identical to the original copy.
m2 <- convertToR(o)
identical(m1, m2)
```

Both `convertToJava()` and `convertToR()` feature several data conversion parameters that will be covered in following sections.

## Converting R Objects to Java Objects

The jdx package provides a single function, `convertToJava()`, to handle conversion for all R objects instead of providing separate functions for vectors, arrays, data frames, etc. This design facilitates dynamically-typed programming. Consider, for example, an overloaded Java method `setValue()`, that has different method signatures for a wide variety of data types and structures. If we use `rJava::.jcall(object, "V", "setValue", convertToJava(value))`, the correct Java method is automatically selected based on the return value of `convertToJava()`.

The `convertToJava()` function provides several data conversion parameters:

```{r eval=FALSE}
convertToJava(
  value,
  length.one.vector.as.array = FALSE,
  scalars.as.objects = FALSE,
  array.order = "row-major",
  data.frame.row.major = TRUE,
  coerce.factors = TRUE
)
```

The parameters `length.one.vector.as.array` and `scalars.as.objects` control if and how length one vectors are converted to Java scalars. The parameter `array.order` affects the index order of matrices and n-dimensional arrays. The parameter `data.frame.row.major` specifies whether data frames are converted using row-major or column-major order. Finally, `coerce.factors` determines whether an attempt should be made to coerce the character vector backing factors to `double`, `int`, or `boolean` Java arrays. The following sections cover each of these topics in detail as well as data conversion rules and behaviors.

### R Vectors of Length One

The parameters `length.one.vector.as.array` and `scalars.as.objects` control how R vectors of length one are converted to Java objects. If `length.one.vector.as.array` is `TRUE`, length-one vectors are converted to Java arrays. This is equivalent to passing an R vector to `rJava::.jarray`. The "As Is" R function, `base::I()`, can also be used to indicate that a length-one vector should be converted to a Java array. For example, `convertToJava(I(1))` produces a Java array even though the default value for `length.one.vector.as.array` is `FALSE`. The `I()` function has no effect for other R object types.

If `length.one.vector.as.array` is `FALSE` (the default), length-one vectors are handled as scalar values. If `scalars.as.objects` is also `FALSE` (the default), `convertToJava()` will return the original R vector instead of creating a Java object for `numeric`, `integer`, `logical`, and `character` length-one vectors. rJava requires these structures to indicate Java `double`, `int`, `boolean`, and `String` method parameters, respectively. However, if the R vector type is `raw`, `convertToJava()` returns an object of class `jbyte` to notify rJava that the value should be converted to a Java `byte` scalar.

If `length.one.vector.as.array` is `FALSE` and `scalars.as.objects` is `TRUE`, length-one vectors will be converted to so-called *boxed* scalars. That is, `numeric`, `integer`, `logical`, `raw`, and `character` vectors of length one are converted to `java.lang.Double`, `java.lang.Integer`, `java.lang.Boolean`, `java.lang.Byte`, and `java.lang.String` objects, respectively.

The `logical` value `NA` is coerced to Java `false` with a warning.

The following two tables detail the behavior of `convertToJava()` for length-one vectors when `length.one.vector.as.array = FALSE`.

```{r results='asis', echo=FALSE}
# load(rdata.tables)
# Highlight the appropriate section in mapping.xlsx before executing the next line
# r2j.length.one.vector.scalars.as.objects.false <- mt(9, 4, what = character(), write.to.clipboard = FALSE)
# file.remove(rdata.tables)
# save.image(file = rdata.tables)
pander::pander(
  r2j.length.one.vector.scalars.as.objects.false
  , split.cells = c("0%", "20%", "20%", "20%", "40%")
  , split.table = 120
  , justify = "left"
  , caption = "`convertToJava()` behavior for length-one vectors when `length.one.vector.as.array = FALSE` and `scalars.as.objects = FALSE`"
  , emphasize.strong.rows = 1
)
```

<br>

```{r results='asis', echo=FALSE}
# load(rdata.tables)
# Highlight the appropriate section in mapping.xlsx before executing the next line
# r2j.length.one.vector.scalars.as.objects.true <- mt(9, 4, what = character(), write.to.clipboard = FALSE)
# file.remove(rdata.tables)
# save.image(file = rdata.tables)
pander::pander(
  r2j.length.one.vector.scalars.as.objects.true
  , split.cells = c("0%", "20%", "20%", "20%", "40%")
  , split.table = 120
  , justify = "left"
  , caption = "`convertToJava()` behavior for length-one vectors when `length.one.vector.as.array = FALSE` and `scalars.as.objects = TRUE`"
  , emphasize.strong.rows = 1
)
```

### R Vectors, One-dimensional Arrays, and One-dimensional Tables

The `convertToJava()` functionality for vectors, one-dimensional arrays, and one-dimensional tables is summarized in the table below. In this case, `convertToJava()` is the same as `rJava::.jarray()` with one exception: `convertToJava()` raises a warning when the `logical` value `NA` is replaced with `FALSE`.

```{r results='asis', echo=FALSE}
# load(rdata.tables)
# Highlight the appropriate section in mapping.xlsx before executing the next line
# r2j.vectors <- mt(9, 4, what = character(), write.to.clipboard = FALSE)
# file.remove(rdata.tables)
# save.image(file = rdata.tables)
pander::pander(
  r2j.vectors
  , split.cells = c("0%", "20%", "20%", "20%", "40%")
  , split.table = 120
  , justify = "left"
  , caption = "`convertToJava()` behavior for vectors, one-dimensional arrays, and one-dimensional tables"
  , emphasize.strong.rows = 1
)
```

### R Factors

R factors are comprised of a `character` vector of levels and an `integer` vector of indexes that reference the levels. For example, if the `integer` vector `5:7` is converted to a factor, the levels will be `c("5", "6", "7")` and the indexes will be `c(1, 2, 3)`. The `coerce.factors` parameter for `convertToJava()` determines how the factor levels are handled when converting the factor to a vector before it's converted to a Java array. If `coerce.factors = TRUE` (the default), an attempt is made to coerce the factor levels to `integer`, `numeric`, or `logical` values. If coercion fails, the `character` levels are used. If `coerce.factors = FALSE`, the `character` levels are always used. Once the factor is converted to a vector, the conversion to Java follows the same mapping rules as vectors.

`NA` values present in factors are preserved. However, the `character` value `"NA"` will not be coerced to `NA`.

### R Matrices and N-dimensional Arrays # {#r_n_dimensional_arrays}

The jdx package supports data exchange for n-dimensional arrays (matrices are two-dimensional arrays). Three array index ordering schemes are available via the `converToJava()` parameter `array.order`: `'row-major'`, `'column-major'`, and `'row-major-java'`. Before describing these schemes, it is helpful to think of n-dimensional arrays as collections of smaller structures. A one-dimensional array (a vector) is a collection of scalars. A two-dimensional array (a matrix) is a collection of one-dimensional arrays representing either rows or columns. A three-dimensional array (a rectangular prism or cube) is a collection of matrices. A four-dimensional array is a collection of cubes, and so forth. Java n-dimensional arrays are literally constructed in this fashion. R n-dimensional arrays, on the other hand, are stored in memory as a vector and the data is retrieved in the appropriate order using so-called indexing arithmetic.

Now we describe the each of the `array-order` options.

+ `'row-major'` -- The indexes of an n-dimensional array are ordered `[row][column][matrix]...[n]`. The jdx package defaults to `'row-major'` because R uses this indexing order. However, this scheme is not intuitive for Java programmers when n > 2 because Java n-dimensional arrays are constructed as large objects containing smaller objects. The data contained in the one-dimensional arrays in a Java n-dimensional structure represent neither rows nor columns.

+ `'column-major'` -- The indexes of an n-dimensional array are ordered `[n]...[matrix][column][row]`. This ordering scheme is natural for Java programmers: the data contained in the one-dimensional arrays represent columns of the parent matrix.

+ `'row-major-java'` -- The indexes of an n-dimensional array are ordered `[n]...[matrix][row][column]`. This provides Java programmers with a natural indexing scheme where the arrays at the one-dimensional level represent rows of the parent matrix. This order is the same as `'row-major'` for matrices.

The following table shows how `convertToJava()` maps n-dimensional R structures to Java structures.

```{r results='asis', echo=FALSE}
# load(rdata.tables)
# Highlight the appropriate section in mapping.xlsx before executing the next line
# r2j.arrays <- mt(9, 4, what = character(), write.to.clipboard = FALSE)
# file.remove(rdata.tables)
# save.image(file = rdata.tables)
pander::pander(
  r2j.arrays
  , split.cells = c("0%", "20%", "20%", "20%", "40%")
  , split.table = 120
  , justify = "left"
  , caption = "`convertToJava()` behavior for vectors, one-dimensional arrays, and one-dimensional tables"
  , emphasize.strong.rows = 1
)
```

### R Data Frames

The `data.frame.row.major` parameter of the `convertToJava()` function specifies whether data frames are converted using row-major or column-major form. When `data.frame.row.major = TRUE` (the default), the result is an `ArrayList<LinkedHashMap<String, Object>>` object where each map object represents a row in the data frame. The key/value pairs in the map are the names and scalar values associated with each field in the row. The row values follow the same conversion rules as vectors of length one when `length.one.vector.as.array = FALSE` and `scalars.as.objects = TRUE`.

When `data.frame.row.major = FALSE`, `convertToJava()` creates a `LinkedHashMap<String, Object>` object. In this case, the key/value pairs represent column names and data. The column data are converted to primitive Java arrays using the same rules as R vectors.

**NOTE:** The jdx package uses row-major ordering by default because of its popularity. However, column-major structures are much faster to create and they often present a performance advantage for calculations.

### R Lists and Environments

The jdx package supports data exchange for lists, named lists, nested lists (lists containing other lists), and environments. The `convertToJava()` function converts R lists to Java `ArrayList<Object>` objects. It converts named lists and `environment` objects to Java `LinkedHashMap<String, Object>` objects. The `ArrayList` and `LinkedHashMap` objects implement the Java `Collection` and `Map` interfaces, respectively, that are ubiquitous in the Java API.

## Converting Java Objects to R Objects

The jdx function `javaToR()` is used to convert generic Java objects to R objects. Java scalars, arrays, maps, and collections are supported. Providing data exchange for maps and collections extends application integration capabilities considerably because a large number of Java classes expose these interfaces. For example, virtually every list, set, and queue object in the standard Java API implements the `java.util.Collection` interface.

**NOTE:** Java collections and maps are converted to a variety of R objects depending on content. See the related sections below for conversion rules.

All of the primitive Java data types and their object (boxed) counterparts (e.g. `int` and `java.lang.Integer`) are supported. In addition, jdx supports `java.lang.String` (of course), `java.math.BigDecimal`, and `java.math.BigInteger`. 

### Java Scalars

### Java One-dimensional Arrays and N-dimensional Rectangular Arrays

The `convertToR` function converts one-dimensional Java arrays to R vectors and it converts n-dimensional rectangular Java arrays to n-dimensional R arrays. The `array.order` parameter controls index ordering for n-dimensional arrays and behaves the same way as in `convertToJava()`. See [R Matrices and N-dimensional Arrays](#r_n_dimensional_arrays) for details.

**IMPORTANT:** Convert 

If an object array contains `null`, it is replaced by the appropriate R `NA` value or a constant. See the following table for details.

```{r results='asis', echo=FALSE}
# load(rdata.tables)
# Highlight the appropriate section in mapping.xlsx before executing the next line
# j2r.arrays <- mt(9, 4, what = character(), write.to.clipboard = FALSE)
# file.remove(rdata.tables)
# save.image(file = rdata.tables)
pander::pander(
  r2j.arrays
  , split.cells = c("0%", "20%", "20%", "20%", "40%")
  , split.table = 120
  , justify = "left"
  , caption = "`convertToJava()` behavior for vectors, one-dimensional arrays, and one-dimensional tables"
  , emphasize.strong.rows = 1
)
```

### Java Ragged Arrays

### Java Maps

(java.util.Map Interface)

### Java Collections # {#java_collections}

 (java.util.Collection Interface)

## R raw Values and Java byte Values # {#R_raw_Java_byte}

The jdx package converts R `raw` values to Java `byte` values and vice versa. R raw values and Java bytes are both 8 bits, but they are interpreted differently. R raw values range from 0 to 255 (i.e., unsigned bytes). Java byte values range from -128 to 127 (i.e., signed bytes). The 8-bit value 0xff represents 255 in R, but is -1 in Java. Usually, `raw` and `byte` values are used to store and transfer binary data such as images, so this discrepancy is not an issue. If the numeric values are important, use `integer` instead of `raw`.

The jdx package handles `raw` vectors and Java `byte` values differently than rJava in some cases. The differences are detailed below, but the general idea is that jdx is consistent in converting R `raw` values to Java `byte` values and vice versa for all data structures.

The rJava package uses the `.jbyte()` function to indicate that a length-one `raw` vector should be treated as a `byte` scalar. Otherwise, rJava interprets length-one `raw` values as Java `byte` arrays. In jdx, length-one `raw` vectors marked as Java `byte` scalars by default. To override this behavior, use `convertToJava(value, length.one.vector.as.array = TRUE)` or `convertToJava(I(value))`  where `value` is a `raw` vector.

By default, rJava converts Java `byte` and `java.lang.Byte` scalars to length-one `integer` vectors. The jdx package converts these values to length-one `raw` vectors.

Finally, when the jdx package encounters `null` in a `java.lang.Byte` array when converting it to an R vector, it replaces `null` with `0x00` and raises a warning.

